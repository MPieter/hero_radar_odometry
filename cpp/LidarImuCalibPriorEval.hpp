//////////////////////////////////////////////////////////////////////////////////////////////
/// \file LidarImuCalibPriorEval.hpp
///
/// \author David Yoon, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef LIDAR_IMU_CALIB_PRIOR_EVAL_HPP
#define LIDAR_IMU_CALIB_PRIOR_EVAL_HPP

#include <steam.hpp>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Error evaluator for penalizing a z-offset and non-zero elevation and roll offsets
///        for a transform variable. Specifically designed for an extrinsic transform between
///        a 3D lidar and 2D radar sensor, assuming they are mounted on parallel planes.
//////////////////////////////////////////////////////////////////////////////////////////////
class LidarImuCalibPriorEval : public ErrorEvaluator<3,6>::type
{
public:

  /// Convenience typedefs
  typedef boost::shared_ptr<LidarImuCalibPriorEval> Ptr;
  typedef boost::shared_ptr<const LidarImuCalibPriorEval> ConstPtr;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  LidarImuCalibPriorEval(const double& z_offset,
                         const se3::TransformEvaluator::ConstPtr& T_radar_lidar);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Returns whether or not an evaluator contains unlocked state variables
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual bool isActive() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Evaluate the measurement error
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual Eigen::Matrix<double,3,1> evaluate() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Evaluate the measurement error and relevant Jacobians
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual Eigen::Matrix<double,3,1> evaluate(
      const Eigen::Matrix<double,3,3>& lhs,
      std::vector<Jacobian<3,6> >* jacs) const;

  void testJacobians() const;

private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Measurement
  //////////////////////////////////////////////////////////////////////////////////////////////
  double z_offset_ = 0;

  ////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Evaluator variables
  ////////////////////////////////////////////////////////////////////////////////////////////// 
  se3::TransformEvaluator::ConstPtr T_radar_lidar_;
  se3::PositionEvaluator::ConstPtr r_rl_in_l_;

};

} // steam

#endif // LIDAR_IMU_CALIB_PRIOR_EVAL_HPP